# 自曝光协议与二级报错集成方案

## 1. 问题分析

### 1.1 原始问题
在之前的调试中发现，智能体模板API调用了 `BaseAgent.process_message()` 方法，但该方法实际不存在，导致运行时出现 `AttributeError`。这个问题的根源在于：

1. **调用方假设接口存在**：API层直接假设 `BaseAgent` 提供 `process_message` 方法
2. **没有接口验证机制**：调用前未查询或验证接口是否存在
3. **错误发现太晚**：只有在运行时才发现接口不存在
4. **违反自曝光协议**：组件间没有通过协议进行接口声明和查询

### 1.2 二级报错机制的缺失
虽然系统设计了二级报错机制（组件级错误 → 系统级错误），但在接口调用场景中没有得到很好的实现：

- **组件无法主动报错**：当组件发现需要的接口不存在时，只能等待运行时报错
- **缺少预防性报错**：没有在调用前验证接口并主动报告缺失
- **错误上报不完整**：缺少接口缺失的专门错误类型和上报机制

## 2. 解决方案设计

### 2.1 核心思想

**"组件查询发现接口缺失时，主动向系统报告错误，而不是等测试再来发现"**

基于这一思想，我们设计了**自曝光协议管理器 + 二级报错系统**的集成方案：

```
组件A需要调用组件B的方法
    ↓
通过自曝光协议查询组件B接口
    ↓
接口存在？
├─ 是 → 返回方法规范，正常调用
└─ 否 → 触发二级报错机制
         ├─ 生成组件级错误（含上下文和修复建议）
         ├─ 上报到错误处理服务
         ├─ 通知智能体和IDE
         └─ 返回 None，阻止错误调用
```

### 2.2 技术架构

```
┌─────────────────────────────────────────────────────────┐
│              自曝光协议管理器                             │
│   (SelfExposeProtocol - src/self_expose_protocol.py)    │
├─────────────────────────────────────────────────────────┤
│ • 组件接口注册表                                          │
│ • 接口查询和验证                                          │
│ • 安全调用机制 (safe_call)                               │
│ • 接口缺失主动报错                                        │
└──────────────────┬──────────────────────────────────────┘
                   │ 接口缺失时触发
                   ↓
┌─────────────────────────────────────────────────────────┐
│              二级报错系统                                 │
│      (ErrorReportingService - src/error_reporting.py)   │
├─────────────────────────────────────────────────────────┤
│ • 组件级错误上报 (component_error)                       │
│ • 系统级错误聚合 (system_error)                          │
│ • 智能体通知                                             │
│ • IDE集成                                                │
└─────────────────────────────────────────────────────────┘
```

## 3. 实现细节

### 3.1 组件自曝光声明

每个组件在文件头部使用 `@self-expose` 注释声明接口：

```python
# @self-expose: {
#   "id": "base_agent",
#   "name": "Base Agent",
#   "type": "agent",
#   "version": "1.0.0",
#   "needs": {
#     "deps": ["agent_tool_integration", "vector_database"],
#     "resources": []
#   },
#   "provides": {
#     "capabilities": ["基础智能体能力", "工具调用", "记忆管理"],
#     "methods": {
#       "respond": {
#         "signature": "(message: str) -> Dict[str, Any]",
#         "description": "处理用户消息并返回响应"
#       },
#       "call_tool": {
#         "signature": "(tool_name: str, parameters: Dict[str, Any]) -> Dict[str, Any]",
#         "description": "委托工具集成器调用具体工具"
#       }
#     }
#   }
# }
```

**关键字段说明**：
- `id`：组件唯一标识
- `provides.methods`：声明所有对外提供的方法及其签名
- `needs.deps`：声明依赖的其他组件

### 3.2 接口注册机制

组件启动时向自曝光协议管理器注册接口：

```python
from src.self_expose_protocol import register_component

# 注册 BaseAgent 接口
base_agent_spec = {
    "id": "base_agent",
    "provides": {
        "methods": {
            "respond": {
                "signature": "(message: str) -> Dict[str, Any]",
                "description": "处理用户消息并返回响应"
            }
        }
    }
}

register_component("base_agent", base_agent_spec)
```

### 3.3 安全调用机制（核心）

调用方使用 `safe_call` 方法调用其他组件接口：

```python
from src.self_expose_protocol import safe_call

# 安全调用：查询接口前先验证，缺失则主动报错
method_spec = safe_call(
    caller_id="stable_start_server",  # 调用方ID
    component_id="base_agent",        # 被调用组件ID
    method_name="respond",            # 方法名
    context={                         # 上下文信息（用于错误报告）
        "endpoint": "/api/agent-template/message",
        "user_message": "测试消息"
    }
)

if method_spec:
    # 接口存在，可以安全调用
    print(f"方法签名: {method_spec['signature']}")
    # 执行实际调用...
else:
    # 接口不存在，已触发二级报错，不能调用
    print("接口缺失，已报错")
```

### 3.4 二级报错触发

当 `safe_call` 发现接口缺失时，自动触发二级报错：

```python
def report_interface_missing(caller_id, component_id, method_name, context):
    """报告接口缺失错误（二级报错机制）"""
    # 生成组件级错误
    component_error = {
        "error_id": "...",
        "level": "component",
        "type": "InterfaceMissingError",
        "message": f"组件 {caller_id} 尝试调用 {component_id}.{method_name}，但该方法不存在",
        "timestamp": "...",
        "component": caller_id,
        "function": "interface_query",
        "context": {
            "caller_id": caller_id,
            "target_component": component_id,
            "missing_method": method_name,
            "available_methods": [...]  # 列出可用方法
        },
        "severity": "error",
        "suggestion": "..."  # 修复建议
    }
    
    # 上报到二级报错系统
    error_service.report_component_error(component_error)
```

### 3.5 错误数据结构

**组件级错误（InterfaceMissingError）**：
```json
{
  "error_id": "stable_start_server-interface_missing-2025-12-03T10:00:00",
  "level": "component",
  "type": "InterfaceMissingError",
  "message": "组件 stable_start_server 尝试调用 base_agent.process_message，但该方法不存在",
  "timestamp": "2025-12-03T10:00:00",
  "component": "stable_start_server",
  "function": "interface_query",
  "context": {
    "caller_id": "stable_start_server",
    "target_component": "base_agent",
    "missing_method": "process_message",
    "available_methods": ["respond", "call_tool", "create_memory"],
    "user_context": {
      "endpoint": "/api/agent-template/message",
      "user_message": "测试消息"
    }
  },
  "severity": "error",
  "suggestion": "1. 组件 base_agent 已注册，但不提供方法 process_message\n2. 可用方法列表: respond, call_tool, create_memory\n3. 请在 base_agent 中实现方法 process_message\n4. 或者修改 stable_start_server 调用已有的方法"
}
```

**系统级错误（自动聚合）**：
```json
{
  "error_id": "system-2025-12-03T10:00:00",
  "level": "system",
  "type": "stable_start_server_failure",
  "message": "关键组件 stable_start_server 发生错误",
  "timestamp": "2025-12-03T10:00:00",
  "affected_components": ["stable_start_server"],
  "severity": "critical",
  "component_errors": ["stable_start_server-interface_missing-2025-12-03T10:00:00"],
  "system_state": {
    "cpu_usage": "unknown",
    "memory_usage": "unknown",
    "disk_usage": "unknown"
  },
  "impact": "stable_start_server 功能完全不可用"
}
```

## 4. 使用示例

### 4.1 为组件添加自曝光声明

**步骤1**：在组件文件头部添加 `@self-expose` 注释

```python
# src/base_agent.py

# @self-expose: {
#   "id": "base_agent",
#   "provides": {
#     "methods": {
#       "respond": {...},
#       "call_tool": {...}
#     }
#   }
# }

class BaseAgent:
    def respond(self, message: str):
        """处理用户消息"""
        pass
```

**步骤2**：在系统启动时注册组件

```python
# stable_start_server.py

from src.self_expose_protocol import register_component

# 启动时注册 BaseAgent
base_agent_spec = {...}  # 从 @self-expose 注释提取
register_component("base_agent", base_agent_spec)
```

### 4.2 安全调用其他组件

**错误示例（不使用协议）**：
```python
# 直接调用，运行时才发现错误
agent = BaseAgent()
result = agent.process_message(user_message)  # AttributeError!
```

**正确示例（使用协议）**：
```python
from src.self_expose_protocol import safe_call

# 1. 查询接口是否存在
method_spec = safe_call(
    caller_id="stable_start_server",
    component_id="base_agent",
    method_name="process_message",
    context={"endpoint": "/api/agent-template/message"}
)

# 2. 根据查询结果决定是否调用
if method_spec:
    # 接口存在，安全调用
    agent = BaseAgent()
    result = agent.process_message(user_message)
else:
    # 接口不存在，已触发二级报错，不能调用
    # 系统已自动报告错误，开发者将收到通知
    return {"error": "接口不存在"}
```

### 4.3 运行测试

```bash
# 运行测试脚本
python test_self_expose_protocol.py
```

**测试输出示例**：
```
============================================================
测试组件自曝光协议和二级报错机制
============================================================

步骤1: 注册 BaseAgent 接口
------------------------------------------------------------
✓ BaseAgent 注册成功

步骤2: 正确调用 - 查询已存在的方法
------------------------------------------------------------
✓ 接口查询成功:
  方法签名: (message: str) -> Dict[str, Any]
  方法描述: 处理用户消息并返回响应

步骤3: 错误调用 - 查询不存在的方法（触发二级报错）
------------------------------------------------------------
✗ 接口不存在 - 已触发二级报错机制
  系统已自动向错误上报服务报告此问题
  智能体和IDE将收到错误通知
```

## 5. 技术优势

### 5.1 预防性报错
- **提前发现错误**：在接口调用前发现缺失，而不是运行时才报错
- **主动上报机制**：组件主动向系统报告错误，无需等待测试
- **完整上下文信息**：错误报告包含调用方、被调用方、上下文和修复建议

### 5.2 降低调试难度
- **清晰的错误信息**：明确指出哪个组件调用了哪个不存在的方法
- **智能修复建议**：自动列出可用方法，提供修改建议
- **快速定位问题**：无需分析堆栈跟踪，直接看到接口缺失原因

### 5.3 系统自我感知
- **智能体自动感知**：错误处理智能体自动收到通知，可以尝试修复
- **IDE集成**：开发者IDE自动显示错误，可以直接跳转到代码位置
- **知识积累**：错误信息写入知识库，避免重复犯错

### 5.4 渐进式引入
- **向后兼容**：未注册的组件仍可以正常调用，只是无法享受协议保护
- **分阶段实施**：可以先为关键组件添加自曝光声明，逐步覆盖全系统
- **低风险**：不影响现有代码运行，只是增加额外的保护层

## 6. 与传统方式对比

| 对比维度 | 传统方式 | 自曝光协议 + 二级报错 |
|---------|---------|---------------------|
| **错误发现时机** | 运行时（太晚） | 调用前（及时） |
| **错误信息** | AttributeError | InterfaceMissingError + 上下文 |
| **修复建议** | 无 | 自动生成（列出可用方法） |
| **智能体感知** | 需要解析堆栈 | 自动接收结构化错误 |
| **IDE感知** | 需要查看日志 | 自动推送错误通知 |
| **预防措施** | 依赖文档 | 接口查询和验证 |
| **系统复杂度** | 低 | 中（值得） |

## 7. 实施路线图

### 第一阶段：基础框架（已完成）
- ✅ 实现 `SelfExposeProtocol` 管理器
- ✅ 集成二级报错系统
- ✅ 实现 `safe_call` 安全调用机制
- ✅ 为 `BaseAgent` 添加自曝光声明
- ✅ 创建测试脚本

### 第二阶段：核心组件覆盖（建议）
- ⏳ 为所有智能体添加自曝光声明
- ⏳ 为关键API端点添加自曝光声明
- ⏳ 修改 `stable_start_server.py` 使用 `safe_call`
- ⏳ 为工具集成器添加自曝光声明

### 第三阶段：自动化工具（未来）
- ⏳ 开发脚本自动提取 `@self-expose` 注释
- ⏳ 实现组件注册表的自动管理
- ⏳ 开发IDE插件显示接口查询结果
- ⏳ 实现接口变更检测和通知

### 第四阶段：智能化增强（未来）
- ⏳ 智能体自动修复接口缺失错误
- ⏳ 基于历史错误预测接口问题
- ⏳ 自动生成接口适配层
- ⏳ 可视化组件依赖图谱

## 8. 最佳实践

### 8.1 声明规范
1. **完整性**：声明所有对外提供的方法，包括签名和描述
2. **准确性**：确保声明与实现一致
3. **版本管理**：接口变更时更新版本号

### 8.2 调用规范
1. **优先使用 safe_call**：涉及跨组件调用时，使用 `safe_call` 而非直接调用
2. **提供上下文**：调用时提供完整上下文信息，便于错误分析
3. **处理返回值**：检查 `safe_call` 返回值，处理接口不存在的情况

### 8.3 错误处理
1. **主动报错**：发现接口缺失时不要沉默，触发二级报错
2. **清晰建议**：错误信息应包含可执行的修复建议
3. **持续改进**：分析错误日志，优化接口设计

## 9. 总结

通过集成**自曝光协议**和**二级报错机制**，我们实现了：

✅ **组件在查询发现接口缺失时，主动向系统报错，而不是等测试再来发现**

这个方案的核心价值在于：
1. **预防胜于治疗**：在接口调用前验证，提前发现问题
2. **主动报错机制**：组件自己发现问题并报告，无需被动等待
3. **完整错误上下文**：提供足够信息帮助快速定位和修复
4. **系统自我感知**：智能体和IDE自动感知错误，形成闭环

这正是您设计的二级报错制度的真正落地，让系统具备了真正的"自我感知"和"主动预防"能力。
