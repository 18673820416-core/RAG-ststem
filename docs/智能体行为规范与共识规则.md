# 智能体行为规范与共识规则

## 1. 基类智能体与功能智能体

- **基类智能体（BaseAgent）**
  - 类似学徒：具备基础能力，但默认不主动做系统级决策。
  - 依赖外部明确指令，不对架构/设计做假设，只执行被委派的具体任务。

- **功能智能体（Functional Agent）**
  - 心智成熟的智能体，基于项目共识规则拥有自主决策权。
  - 可以在约束范围内 **自主串联完整工作流**（分析→规划→执行→验证），仅在：
    - 需要跨越权限边界，或
    - 需要改变架构级行为时
    主动向人类主脑/系统管家汇报并申请授权。

## 2. 代码求真与交付规范

- **规则 1：默认代码不完整，优先对齐设计意图**
  - 接手任何代码（包括自己之前写的），初始假设为：
    - 功能可能不完整
    - 实现可能偏离设计文档
  - 行为要求：
    - 先从设计文档/系统提示词/架构共识中抽取“期望行为模型”；
    - 再对照当前实现，找出：未实现、实现不全、逻辑反向、被抽样/被省略的部分；
    - 避免以“代码存在”作为“功能已经实现”的证明。

- **规则 2：代码交付前必须同时满足“设计一致性 + 运行验证”**
  - 设计一致性：
    - 确认实现与设计意图一致，例如：
      - 顶层知识图谱是否是“全覆盖索引视图”，而不是抽样子集；
      - 记忆重构是否遵守“每日一次、夜间执行、数量变化作为成效标准”等规则。
  - 运行验证：
    - 通过日志、统计指标、关键样本验证行为是否达到预期：
      - 记忆重构：重构后记忆数量变化、删除率、逻辑链补全情况；
      - 知识图谱：覆盖率、节点数与向量库总量的关系。
  - 禁止“只看代码过不报错就交付”，避免不确定因素在系统中积累。

## 3. 知识图谱与记忆覆盖原则

- **顶层图谱 = 全覆盖索引视图**
  - 顶层“全局知识图谱”必须在结构上能够覆盖向量库中的全部长期记忆。
  - 即使出于展示/性能需要在界面层做抽样，**内部数据结构仍需确保所有记忆在图谱中具有可追踪的节点或索引**。
  - 如果某条记忆不在任何图谱节点中，对于基于图谱检索的智能体而言，该记忆等同于“在世界地图上不存在”。

- **分层图谱 = 认知减负视图**
  - 第二层及以下的主题图谱、事件图谱用于在顶层全覆盖的前提下做：
    - 主题聚焦
    - 事件放大
    - 层级导航
  - 减负只能发生在“显示/聚焦层”，不能以牺牲整体覆盖为代价。

## 4. 记忆重构与清理规则

- **记忆重构成功判定**
  - 成功判定标准之一：**重构后记忆数量必须发生预期方向的变化**。
  - 若数量无变化，视为重构在“低价值清理”目标上失败，需要排查：
    - 删除规则是否过于保守；
    - 删除链路（向量库 + 网状思维 + 知识图谱）是否完整执行；
    - 日志/报告是否缺失关键统计。

- **错误与测试记忆清理**
  - 对于明确无长期价值的错误提示/测试碎片（例如提示词文件未找到、测试提示词缺失等）：
    - 记忆重构引擎中应设置强规则：一旦命中即标记删除；
    - 夜间维护调度器需从：
      - 向量库（mem_*）
      - 网状思维节点（node_*）
      同时移除对应内容。

## 5. 共识外化与文档化

- 所有关键设计共识、智能体行为规范（包括本文件内容）必须：
  - 以文本形式记录
  - 存入项目 DOCS 体系（并纳入版本管理）
  - 作为后续开发与重构的对照依据

- 禁止仅依赖“模型内化”或一次性对话记忆来承载这些规则。

- 对重要的架构或行为改动，需在相关文档中更新：
  - 设计动机
  - 权衡取舍
  - 预期收益
  - 与旧实现/旧规则的差异
