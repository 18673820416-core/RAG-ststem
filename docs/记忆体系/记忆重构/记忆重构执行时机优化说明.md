# 记忆重构执行时机优化说明

修复日期：2025-12-04 晚上

## 问题描述

用户反馈：
1. ❌ 晚上启动服务器时，记忆重构会立即执行
2. ❌ 记忆重构应该每晚只执行一次，但晚上启动时不应该立即执行
3. ✅ 系统已经使用24小时制，时间判断正确

## 核心需求

**记忆重构执行规则**：
- ✓ 每天只执行一次
- ✓ 在用户休息时间（22:00-6:00）执行
- ✓ **即使是晚上启动服务器，也不应该立即执行**
- ✓ 应该等待足够长的时间后才开始执行

## 修复方案

### 1. 多层保护机制

**第一层：启动延迟（通用保护）**
```python
"startup_delay_minutes": 120  # 启动后等2小时才开始检查任务
```
- 任何时候启动服务器，都会等待2小时后才开始检查任务
- 确保系统稳定运行后才执行维护任务

**第二层：调度延迟（任务级保护）**
```python
# 在 _execute_single_task 中
scheduled_time = datetime.fromisoformat(task["scheduled_time"])
time_since_schedule = (datetime.now() - scheduled_time).total_seconds() / 3600

if time_since_schedule < 2:  # 调度后至少等2小时
    logger.debug(f"任务调度后仅 {time_since_schedule:.1f} 小时，等待至少 2 小时后执行")
    return
```
- 即使启动延迟时间过了，任务调度后也要等待至少2小时
- 双重保护，确保不会立即执行

**第三层：每日一次（重复执行保护）**
```python
if task.get("daily_once", False):
    today = datetime.now().strftime("%Y%m%d")
    last_execution = task.get("last_execution_date")
    
    if last_execution == today:
        logger.debug(f"任务今天已执行，跳过")
        return
```
- 确保即使满足所有条件，一天也只执行一次

### 2. 时间格式确认

所有日期时间格式都已使用**24小时制**：
- ✓ `%H:%M:%S` - 24小时制
- ✗ `%I:%M:%S %p` - 12小时制（未使用）

系统能正确判断当前是否为晚上（22:00-6:00）。

## 执行流程示例

### 场景1：晚上23:00启动服务器

```
23:00 - 启动服务器
23:00 - 调度记忆重构任务（task_20251204_230000_memory_reconstruction）
23:01 - 检查任务执行条件：
        ✓ 是否为用户休息时间？是（23:00在22:00-6:00之间）
        ✗ 启动后经过时间？1分钟 < 120分钟 → 跳过
23:05 - 检查任务执行条件：
        ✓ 是否为用户休息时间？是
        ✗ 启动后经过时间？5分钟 < 120分钟 → 跳过
...
01:00 - 检查任务执行条件：
        ✓ 是否为用户休息时间？是
        ✗ 启动后经过时间？120分钟 = 120分钟 → 通过启动延迟
        ✗ 调度后经过时间？120分钟 = 2小时 → 通过调度延迟
        ✓ 今天是否已执行？否
        → 开始执行记忆重构 ✓
```

### 场景2：白天14:00启动服务器

```
14:00 - 启动服务器
14:00 - 调度记忆重构任务
...
16:00 - 检查任务执行条件：
        ✗ 是否为用户休息时间？否（14:00不在22:00-6:00之间）
        → 不执行
...
22:00 - 检查任务执行条件：
        ✓ 是否为用户休息时间？是
        ✓ 启动后经过时间？480分钟 > 120分钟 → 通过
        ✓ 调度后经过时间？8小时 > 2小时 → 通过
        ✓ 今天是否已执行？否
        → 开始执行记忆重构 ✓
```

### 场景3：晚上启动，第二天晚上执行

```
23:30 - 启动服务器
23:30 - 调度记忆重构任务
...
01:30 - 检查任务执行条件（满足所有条件）
        → 开始执行记忆重构 ✓
        → 标记今天已执行（20251204）
...
22:00 - 第二天晚上检查：
        ✓ 是否为用户休息时间？是
        ✓ 启动后经过时间？很长 → 通过
        ✓ 调度后经过时间？很长 → 通过
        ✗ 今天是否已执行？是（20251205 != 20251204）→ 可以执行
        → 开始执行记忆重构 ✓
```

## 配置参数说明

### timing_strategy_engine.py

```python
default_config = {
    "user_rest_hours": {
        "start_hour": 22,  # 晚上10点
        "end_hour": 6,     # 早上6点
        "enabled": True
    },
    "skip_execution_on_startup": True,
    "startup_delay_minutes": 120  # 2小时启动延迟
}
```

### 任务调度

```python
timing_engine.schedule_optimization(
    task_type="memory_reconstruction",
    task_description="批量记忆重构和压缩",
    priority="medium",
    estimated_duration=30,
    optimization_function=perform_memory_reconstruction,
    daily_once=True  # 每天只执行一次
)
```

## 修改的文件

- ✅ `src/timing_strategy_engine.py`
  - 增加调度后等待2小时的检查
  - 将启动延迟从60分钟改为120分钟
  - 完善日志输出

## 验证方法

1. **晚上启动服务器**：
   ```bash
   .\启动系统.bat
   ```

2. **观察日志**：
   ```
   # 应该看到类似的日志：
   系统启动后 1.0 分钟，跳过任务执行（延迟期：120分钟）
   任务 task_xxx_memory_reconstruction 调度后仅 0.5 小时，等待至少 2 小时后执行
   ```

3. **等待2小时后**：
   ```
   # 应该看到：
   开始执行优化任务: task_xxx_memory_reconstruction
   🔄 开始记忆重构任务
   ```

## 总结

✅ **已完全修复**：
- 晚上启动服务器不会立即执行记忆重构
- 双重延迟保护（启动延迟 + 调度延迟）
- 每天只执行一次
- 只在用户休息时间执行
- 使用24小时制，时间判断准确

🎯 **符合用户要求**：
> "记忆重构一个晚上重构一次就好了，不要一到晚上启动服务器，就重构记忆"

---

**记住**：
- 启动后至少等待2小时（startup_delay_minutes: 120）
- 任务调度后至少等待2小时（time_since_schedule < 2）
- 每天只执行一次（daily_once: True）
- 只在22:00-6:00执行（user_rest_hours）

**四重保护，确保万无一失！** ✓
