# 智能体日志增强方案

## 📋 方案概述

基于用户反馈，当前智能体日志系统需要增强，主要包括：
1. **自动记录日志**：智能体在执行任务时自动记录
2. **后台临时记录**：允许智能体在后台随时记录临时信息
3. **定期日志整理**：将临时记录整理成长期记忆，然后删除临时文件

## 🔧 增强设计

### 1. 自动记录日志功能

**实现方式**：
- 在 `BaseAgent` 类中添加 `auto_log` 装饰器
- 为关键方法添加自动日志记录
- 支持配置自动日志的详细程度

**代码设计**：
```python
# 自动日志装饰器
def auto_log(self, func):
    def wrapper(*args, **kwargs):
        # 记录方法开始执行
        start_time = datetime.now()
        log_content = f"开始执行方法: {func.__name__}"
        self._write_work_log(log_content, "INFO")
        
        try:
            # 执行原方法
            result = func(*args, **kwargs)
            
            # 记录方法执行成功
            end_time = datetime.now()
            execution_time = (end_time - start_time).total_seconds()
            log_content = f"方法执行成功: {func.__name__}, 耗时: {execution_time:.3f}秒"
            self._write_work_log(log_content, "INFO")
            
            return result
        except Exception as e:
            # 记录方法执行失败
            end_time = datetime.now()
            execution_time = (end_time - start_time).total_seconds()
            log_content = f"方法执行失败: {func.__name__}, 耗时: {execution_time:.3f}秒, 错误: {str(e)}"
            self._write_work_log(log_content, "ERROR")
            raise
    return wrapper
```

### 2. 后台临时记录功能

**实现方式**：
- 添加 `_write_temp_log` 方法，用于记录临时信息
- 临时记录存储在独立的临时日志文件中
- 支持配置临时记录的保存期限

**代码设计**：
```python
def _write_temp_log(self, content: str, log_type: str = "TEMP"):
    """写入临时日志"""
    temp_entry = {
        'id': str(uuid.uuid4()),
        'timestamp': datetime.now().isoformat(),
        'agent_id': self.agent_id,
        'agent_type': self.agent_type,
        'data': {
            'type': log_type,
            'content': content
        }
    }
    
    # 保存到临时日志文件
    temp_diary_file = self.diary_file.parent / f"{self.agent_id}_temp_diary.json"
    
    # 读取现有临时日志
    temp_entries = []
    if temp_diary_file.exists():
        with open(temp_diary_file, 'r', encoding='utf-8') as f:
            temp_entries = json.load(f)
    
    # 添加新的临时记录
    temp_entries.append(temp_entry)
    
    # 保存临时日志
    with open(temp_diary_file, 'w', encoding='utf-8') as f:
        json.dump(temp_entries, f, ensure_ascii=False, indent=2)
    
    logger.info(f"临时记录已保存: {log_type} - {content[:50]}...")
```

### 3. 定期日志整理功能

**实现方式**：
- 添加 `_cleanup_temp_logs` 方法，定期整理临时日志
- 将临时记录整理成长期记忆，存入统一记忆系统
- 删除过期的临时记录

**代码设计**：
```python
def _cleanup_temp_logs(self, max_age_hours: int = 24):
    """清理临时日志，将有价值的记录整理成长期记忆"""
    temp_diary_file = self.diary_file.parent / f"{self.agent_id}_temp_diary.json"
    
    if not temp_diary_file.exists():
        return
    
    # 读取临时日志
    with open(temp_diary_file, 'r', encoding='utf-8') as f:
        temp_entries = json.load(f)
    
    if not temp_entries:
        return
    
    # 计算清理时间点
    cleanup_time = datetime.now() - timedelta(hours=max_age_hours)
    
    # 分离需要保留的记录和需要清理的记录
    keep_entries = []
    cleanup_entries = []
    
    for entry in temp_entries:
        entry_time = datetime.fromisoformat(entry['timestamp'])
        if entry_time > cleanup_time:
            keep_entries.append(entry)
        else:
            cleanup_entries.append(entry)
    
    # 如果有需要清理的记录，整理成长期记忆
    if cleanup_entries:
        # 整理记录
        organized_content = self._organize_temp_entries(cleanup_entries)
        
        # 保存到长期记忆
        if organized_content:
            self.create_memory(
                content=organized_content,
                memory_type="work_log",
                priority="medium",
                tags=["organized", "temp_logs"]
            )
            logger.info(f"已将 {len(cleanup_entries)} 条临时记录整理成长期记忆")
    
    # 更新临时日志文件
    with open(temp_diary_file, 'w', encoding='utf-8') as f:
        json.dump(keep_entries, f, ensure_ascii=False, indent=2)
    
    logger.info(f"临时日志清理完成: 保留 {len(keep_entries)} 条，清理 {len(cleanup_entries)} 条")
```

### 4. 日志整理策略

**实现方式**：
- 添加 `_organize_temp_entries` 方法，用于整理临时记录
- 支持按时间、类型、主题等维度整理
- 生成结构化的长期记忆内容

**代码设计**：
```python
def _organize_temp_entries(self, entries: List[Dict[str, Any]]) -> str:
    """整理临时记录，生成结构化的长期记忆内容"""
    if not entries:
        return ""
    
    # 按时间排序
    entries.sort(key=lambda x: x['timestamp'])
    
    # 按类型分组
    entries_by_type = {}
    for entry in entries:
        log_type = entry['data'].get('type', 'unknown')
        if log_type not in entries_by_type:
            entries_by_type[log_type] = []
        entries_by_type[log_type].append(entry)
    
    # 生成整理后的内容
    content_parts = ["# 临时记录整理"]
    content_parts.append(f"\n**整理时间**: {datetime.now().isoformat()}")
    content_parts.append(f"**记录数量**: {len(entries)}")
    content_parts.append(f"**智能体ID**: {self.agent_id}")
    content_parts.append(f"**智能体类型**: {self.agent_type}")
    
    # 按类型添加记录
    for log_type, type_entries in entries_by_type.items():
        content_parts.append(f"\n## {log_type} 类型记录")
        content_parts.append(f"### 记录数量: {len(type_entries)}")
        
        for entry in type_entries:
            entry_time = entry['timestamp']
            entry_content = entry['data'].get('content', '')
            content_parts.append(f"\n**{entry_time}**: {entry_content}")
    
    return "\n".join(content_parts)
```

## 🚀 实现步骤

### 1. 修改 BaseAgent 类
- 添加自动日志装饰器
- 添加后台临时记录方法
- 添加定期日志整理方法
- 为关键方法添加自动日志记录

### 2. 添加配置选项
- 支持配置自动日志的详细程度
- 支持配置临时记录的保存期限
- 支持配置日志整理的时间间隔

### 3. 实现定时任务
- 为智能体添加定时任务，定期执行日志整理
- 支持配置定时任务的执行频率

### 4. 集成统一记忆系统
- 确保临时记录能被正确整理成长期记忆
- 支持将整理后的记录存入统一记忆系统

## 📊 预期效果

1. **智能体自主记录**：智能体在执行任务时自动记录日志，无需手动调用
2. **后台临时记录**：智能体可以随时记录临时信息，减轻认知负担
3. **定期日志整理**：临时记录定期被整理成长期记忆，然后删除临时文件
4. **提高智能体效率**：智能体可以卸载前面的任务认知，着眼于当前任务
5. **优化记忆管理**：临时记录和长期记忆分离，提高记忆检索效率

## 🔮 未来扩展

1. **智能日志分析**：添加智能日志分析功能，自动发现日志中的模式和异常
2. **日志可视化**：添加日志可视化功能，便于用户查看和分析智能体的工作情况
3. **多智能体日志关联**：支持关联多个智能体的日志，便于分析智能体间的协作情况
4. **日志检索优化**：优化日志检索功能，支持更复杂的查询条件
5. **智能日志摘要**：添加智能日志摘要功能，自动生成日志的摘要信息

## 📝 结论

通过增强智能体日志系统，可以提高智能体的工作效率，减轻智能体的认知负担，同时优化记忆管理。该方案符合用户提出的"好记性当不得烂笔头"的理念，充分利用了智能体的文本记录权限，让智能体养成随时记录的习惯，从而变得更强大。